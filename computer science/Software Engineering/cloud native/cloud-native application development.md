Cloud-native application development describes how and where developers build and deploy cloud-native applications. A cultural shift is important for cloud-native development. Developers adopt specific software practices to decrease the software delivery timeline and deliver accurate features that meet changing user expectations. We give some common cloud-native development practices below.

### **[[Continuous integration]]**

[Continuous integration (CI)](https://aws.amazon.com/devops/continuous-integration/) is a software practice in which developers integrate changes into a shared code base frequently and without errors. Small, frequent changes make development more efficient because you can identify and troubleshoot issues faster. CI tools automatically assess the code quality for every change so that development teams can add new features with greater confidence.

### **[[Continuous delivery]]**

[Continuous delivery (CD)](https://aws.amazon.com/devops/continuous-delivery/) is a software practice that supports cloud-native development. With CD, development teams ensure that the microservices are always ready to be deployed to the cloud. They use software automation tools to reduce risk when making changes, such as introducing new features and fixing bugs on applications. CI and CD work together for efficient software delivery.

### **[[DevOps]]**

[DevOps](https://aws.amazon.com/devops/what-is-devops/?trk=faq_card) is a software culture that improves the collaboration of development and operations teams. It is a design philosophy that aligns with the cloud-native model. DevOps practices allow organizations to speed up the software development lifecycle. Developers and operation engineers use DevOps tools to automate cloud-native development. 

### **[[Serverless]]**

Serverless computing is a cloud-native model where the cloud provider fully manages the underlying server infrastructure. Developers use serverless computing because the cloud infrastructure automatically scales and configures to meet application requirements. Developers only pay for the resources the application uses. The serverless architecture automatically removes compute resources when the app stops running.